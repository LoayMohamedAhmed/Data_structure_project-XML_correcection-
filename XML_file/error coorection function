
void error_correction(char* data,int size1)
{
    while(!errors_miss_tag1.empty())
    {
        errors_miss_tag.push(errors_miss_tag1.top());
        errors_miss_tag1.pop();
    }
    cout<<"enter";
    deque<char> l;
    tag temp_tag;
    int flag=0;
    int j=0;
    int index;
    ofstream file2("fixed.txt");
    while(!errors_miss_tag.empty())
    {
        if(errors_miss_tag.top().s[1]=='/')
        {
            int end1=temp_tag.index_end;
            if(flag!=0)
            {
                j=end1+1;
            }
            string word= errors_miss_tag.top().s;
            word.erase(word.begin()+1);
            int i=errors_miss_tag.top().index_start-1;
            while(data[i]!='>')
            {
                i--;
            }
            for(;j<=i;j++)
            {
                l.push_back(data[j]);
            }
            int o=i;
            for(int k=0;k<word.size();k++)
            {
                l.push_back(word[k]);
            }
            for(i+=1;i<=errors_miss_tag.top().index_end;i++)
            {
                l.push_back(data[i]);
            }
            index=i;
        }


        if(flag!=0)
        {
            for(;index<=errors_miss_tag.top().index_end;index++)
                l.push_back(data[index]);

        }




        if(errors_miss_tag.top().s[1]!='/')
        {
            if(flag==0)
            {
                for(int o=0;o<=errors_miss_tag.top().index_end;o++)
                {
                    l.push_back(data[o]);
                }
            }
            int i2=errors_miss_tag.top().index_end+1;
            int j2=errors_miss_tag.top().index_end+1;
            string word = errors_miss_tag.top().s;
            word.insert(1,"/");
            while(data[i2]!='<')
            {
                i2++;
            }
            for(;j2<i2;j2++)
            {
                l.push_back(data[j2]);
            }

            for(int k=0;k<word.size();k++)
            {
                l.push_back(word[k]);
            }
            index=i2;
        }
        flag=1;
        temp_tag=errors_miss_tag.top();
        errors_miss_tag.pop();

    }

    while(!l.empty())
    {
        file2<<l.front();
        l.pop_front();
    }
    for(;index<size1-1;index++)
        file2<<data[index];
    file2.close();
    cout<<"goodbye";

}
